\chapter{Συμπεράσματα και Μελλοντικές Επεκτάσεις}
\label{chapter:end}

\section{Συμπεράσματα}
\label{section:conclusion}

Συνοψίζοντας, παρουσιάζονται συνοπτικά οι υλοποιήσεις μας, τα πλεονεκτήματα και τα μειονεκτήματα κάθε μίας.

\begin{itemize}
	\item \textbf{1\textsuperscript{η} Υλοποίηση}: Το ίδιο μηχάνημα λειτουργεί σαν server και scheduler ταυτόχρονα.
		Κάθε καινούργιο αίτημα προς παρακολούθηση ξεκινάει μία διεργασία εντός του server που εκτελείται επαναληπτικά,
		με ρυθμό ένα συγκεκριμένο χρονικό διάστημα. Η υλοποίηση αυτή λειτουργεί, αλλά, εμφανίζει προβλήματα:
		\begin{itemize}
			\item \textbf{οριζόντιας κλιμάκωσης} λόγω της εξάρτησης που υπάρχει μεταξύ server και worker
			\item \textbf{απόδοσης}, καθώς το φορτίο υπό το οποίο μπορεί να βρίσκεται ο server επηρεάζει τη λειτουργία των jobs που εκτελούνται στο παρασκήνιο 
			\item έλλειψης ενός \textbf{κοινού σημείου αναφοράς}.
		\end{itemize}
	\item \textbf{2\textsuperscript{η} Υλοποίηση}: Το σύστημα χωρίζεται σε δύο ανεξάρτητες οντότητες. Πλέον,
		υπάρχει, στην πιο απλή εκδοχή του συστήματος, ένας server και περισσότεροι από ένας workers. Ο server στεγάζει το API της εφαρμογής και είναι υπεύθυνος
		για την επικοινωνία των χρηστών της εφαρμογής με το σύστημά μας και οι workers εκτελούν αποκλειστικά ελέγχους προς
		τα εξωτερικά συστήματα που ορίζουν οι χρήστες. Η επικοινωνία μεταξύ server και workers σε αυτή την υλοποίηση είναι αμφίδρομη,
		καθώς αξιοποιούμε το πρωτόκολλο των Websockets. Έτσι ο server μπορεί να στέλνει αιτήματα (προς έλεγχο) στους workers,
		και οι workers με τη σειρά τους μπορούν να ενημερώνουν για την κατάσταση τους (πλήθος ενεργών αιτημάτων που διαθέτουν), τον server.
		Το βασικό μειωνέκτημα της συγκεκριμένης υλοποίησης είναι η έλλειψη ενός κοινού σημείου αναφοράς. Ενός σημείου μέσω του οποίου
		θα μπορεί να ελεχθεί το σύνολο του συστήματος χωρίς να χρειάζεται να υπάρχει επικοινωνία μεταξύ των οντοτήτων του Lychte. 
	\item \textbf{3\textsuperscript{η} και Tελική Υλοποίηση}: Υιοθετεί αρκετές αρχές της προηγούμενης υλοποίησης. Server και workers
		αποτελούν ανεξάρτητες οντότητες. Πλεόν, όμως, η επικοινωνία αυτών δεν είναι άμεση, αλλά το ρόλο του μεσολαβητή αναλαμβάνει η
		βάση δεδομένων. Ο server επικοικωνεί με τους workers δημιουργώντας αντικείμενα σε συγκεκριμένα collections ή τροποποιώντας τα κατάλληλα,
		όταν γίνεται κάποια αντίστοιχη ενέργεια από τους χρήστες. Οι workers λειτουργούν πιο έξυπνα, αποφεύγοντας την εκτέλεση αχρείαστων timers
		και schedulers, κρατώντας μόνο όσους από αυτούς χρειάζεται για την ορθή λειτουργία του. Επίσης, εισάγεται μία ακόμα βάση δεδομένων στο σύστημα,
		σκοπός της οποίας είναι η αποθήκευση ιστορικών δεδομένων σε μορφή αρχείων. Έτσι κάποια δεδομένα μπορούν να διαγραφούν από την κεντρική βάση και
		να μεταφερθούν σε αυτή, για να κάνουν την πρώτη πιο αποδοτική και γρήγορη στην ανταπόκριση. 
\end{itemize}

Καταλήγοντας στην τελική υλοποίησή μας, κάναμε κάποιες μετρήσεις, για να ελέγξουμε την απόδοση και την αξιοπιστία του συστήματος, και κυρίως της
λειτουργίας των workers. Ξεκινώντας με ένα σχετικά μικρό πλήθος αιτημάτων που τρέχουν παράλληλα (100 στο πλήθος), και αυξάνοντας
τα σταδιακά (φτάσαμε στα 5.000), είδαμε ότι η μέση απόκλιση του αναμενόμενου χρόνου εκτέλεσης των διάφορων αιτημάτων παραμένει χαμηλή, φτάνοντας μάλιστα
σε ορισμένες περιπτώσεις σε αρνητικές τιμές. Όσον αφορά στην κατανάλωση πόρων του υπολογιστικού συστήματος, παρατηρούμε ότι
αυξάνοντας το πλήθος των αιτημάτων που εκτελούνται παράλληλα από έναν worker, αυξάνονται, μετά από ένα ορισμένο σημείο, κατά πολύ οι απαιτήσεις του
συστήματος. Αυτό μας οδηγεί στο συμπέρασμα, ότι πάντα θα πρέπει να υπάρχουν διαθέσιμοι workers στους οποίους θα
μπορεί να γίνεται καταμερισμός των ενεργών αιτημάτων, ώστε να αποφεύγονται καταστάσεις υπερφόρτωσης του συστήματος.  


\section{Μελλοντικές Επεκτάσεις}
\label{section:future_stuff}

Όπως είδαμε, το σύστημα Lychte που υπολοποιήσαμε στο πλαίσιο της διπλωματικής αυτής
εργασίας δουλεύει σε ένα αρκετά ικανοποιητικό επίπεδο, με τα αποτελέσματα των μετρήσεων που κάνουμε να το αποδεικνύουν.

Υπάρχει όμως ακόμα χώρος για βελτίωση. Όπως είδαμε, όταν το πλήθος των εξωτερικών συστημάτων που θέλουμε να ελέγχουμε
αυξάνεται θα πρέπει να αυξάνεται αντίστοιχα και το πλήθος των workers που λειτουργούν προς την εξυπηρέτηση αυτών. Μία λύση στο πρόβλημα αυτό, και για
την αποφυγή ύπαρξης καταστάσεων που ένας worker δυσλειτουργεί ή το υπολογιστικό σύστημα στο οποίο ζει δεν μπορεί να ικανοποιήσει
τις ανάγκες του ως προς τους πόρους που απαιτεί, είναι η αυτόματη ενημέρωση κάποιου admin, που διαχειρίζεται το σύστημα,
προκειμένου να δημιουργήσει και άλλους worker. Είναι σημαντικό ακόμα να ερευνηθεί στο πλαίσιο αυτό το κομμάτι της κύριας βάσης δεδομένων
που χρησιμοποιούμε. H παρούσα υλοποίηση αξιοποιεί τις δυνατότητες της MongoDB. Υπάρχουν όμως πλήθος άλλων
noSql βάσεων, όπως για παράδειγμα του Redis, η χρήση του οποίου θα μπορούσε να βελτιώσει την απόδοση και την ταχύτητα των
queries στη βάση. Ακόμα, θα μπορούσε να ερευνηθεί το κατά πόσο θα είχε νόημα ο συνδυασμός μίας κύριας και μίας δευτερεύουσας βάσης (πέραν αυτής του Google Cloud Storage),
που θα χρησιμοποιούνται από τις δύο διαφορετικές οντότητες του συστήματός μας, προκειμένου να διαμοιραστεί ο φόρτος των λειτουργιών που κατά βάση εκτελούν οι workers.

Ένας ακόμα τομέας στον οποίο υστερεί το σύστημα, είναι το περιορισμένο πλήθος των τύπων ελέγχου που μπορούμε
να κάνουμε. Σε μελλοντική έκδοση, θα μπορούσαμε να ενσωματώσουμε αιτήματα ελέγχου PORTS, TCP συνδέσεων, αποστολής μηνυμάτων μέσω του πρωτοκόλλου επικοινωνίας MQTT,
καθώς και ελέγχους συνδέσεων και αποστολής μηνυμάτων σε socket.io server. Επιπλέον, θα μπορούσαμε να επεκτείνουμε τα 
μέσα ενημέρωσης (σε περίπτωση προβληματος) των χρηστών. Το τωρινό σύστημα παρέχει δυνατότητες ενημέρωσης μέσω mail, αλλά θα μπορούσαμε ακόμα να επιτρέψουμε
τη σύνδεση άλλων μορφών επικοινωνίας, όπως είναι οι διάφορες messaging εφαρμογές (Slack, Discord). 

Πέρα από τη βελτίωση του backend του συστήματος, θα μπορούσαμε ακόμα να προσθέσουμε παραπάνω διαγράμματα,
αξιοποιώντας περαιτέρω τα αποθηκευμένα δεδομένα μας και δείχνοντας παραπάνω χρήσιμη πληροφορία στο χρήστη.